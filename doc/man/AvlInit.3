.\"
.\" Man page for AvlInit
.\"
.\" $Id$
.\"
.\" $Log$
.\"
.TH AvlInit 3 "08 Feb 94" Common
.SH NAME
AvlInit \- Initialize a AVL tree
.SH SYNOPSIS
#include <Common.h>
.LP
AvlTree AvlInit( 
.PD 0
.RS
.TP 7
int
(*compare)(void * dataOne, void * dataTwo, AvlNode node),
.TP 7
void *
(*getMemory)( size_t size, void * closure ),
.TP 7
void
(*freeMemory)( void * data, void * closure ),
.TP
void *
memClosure )
.RE
.PD
.SH ARGUMENTS
.TP
compare
This will be the funtion used to compare two objects. It must return a
0 (zero) if the two objects are equal, a value greater than 0 if the
first object (dataOne) is greater than the second (dataTwo) and a
value less than 0 if the first object is less than the second (i.e.
dataOne - dataTwo). The node parameter should be ignored. The objects
(dataOne & dataTwo) are the pointers passed to AvlAdd(3) or AvlFind(3).
.TP
getMemory
This should be either NULL or a function that will allocate some
memory for the interal structures used by the Avl functions. It will
be passed the number of bytes needed and the memClosure value. If it
is NULL, malloc is used.
.TP
freeMemory
This should be either NULL or a function that will release memory that
was used for internal structures. If it is NULL, free is used.
.TP
memClosure
The value passed in this parameter will be passed to the getMemory and
freeMemory functions.
.SH DESCRIPTION
Initiazes a AVL tree and returns a token used to identify the tree.
The value returned must be passed as the first argument to all other
Avl functions.
.LP
An AVL tree is a dynamic balanced binary tree for storing and
retieving data objects. This implementation utilizes the comparision
function passed to AvlInit to determine the position of a data object
within the tree. All nodes stored in the tree must be unique (as
determined by the 'compare' function). 
.SH RETURNS
.TP
AvlTree
The token used to identify the tree.
.TP
NULL
An error has occured.
.SH EXAMPLE
.nf
#include <Common.h>

char *  Data[] =
{
    "one string",
    "two string",
    "test string",
    "other string",
    NULL
}

int
CompareNodes(
    void *  dataOne,
    void *  dataTwo,
    AvlNode nd )
{
   return( strcmp( *dataOne, *dataTwo ) );
}


main( int argc, char * argv[] )
{

  AvlTree  avl;
  int      index;

  char *   findData;
  
  if( (avl = AvlInit( CompareNodes, NULL, NULL, NULL ) ) ) == NULL )
    {
      fprintf( stderr, "AvlInit failed\n" );
      exit( 1 );
    }

  for( index = 0; Data[index] != NULL; index++ )
    {
      if( AvlAdd( avl, Data[index] ) != NULL )
        {
	   fprintf( stderr, "AvlAdd failed for: %s\n", Data[index] );
	   exit( 1 );
	}
    }

  if( (findData = AvlFind( avl, "test string" ) ) == NULL )
    {
      fprintf( stderr,"Could Not find\n" );
      exit( 1 );
    }

  if( AvlDel( avl, findData ) == NULL )
    {
      fprintf( stderr, "Could not delete\n" );
      exit( 1 );
    }

  printf( "Done!\n" );
}
.fn
.SH FILES
.PD 0
/usr/local/include/Common.h
.LP
/usr/local/lib/libCommon.a
.PD
.SH "SEE ALSO"
AvlAdd(3), AvlDel(3), AvlFind(3), AvlDispose(3),
AvlWalk(3), AvlCount(3), AvlDelMin(3), AvlFindMin(3),
AvlDelMax(3), AvlFindMax(3)
.LP
G.M. Adelson-Velskii and E.M. Landis. Doklady Akademia Nauk SSSR, 146,
(1962), 263-66; English translation in Soviet Math, 3, 1259-63
.LP
Nikalus Wirth, Algorithms and Data Structures, Prentice-Hall, 1986,
ISBN 0-13-022005-1
.SH AUTHORS
Brad Appleton,
Paul Houghton x2309 - (houghton@shoe) 

